<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Arquitectura del Proyecto: IPS Java/Swing</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<header>
    <h1>Arquitectura del proyecto: IPS Java/Swing</h1>
    <p>Versión: 1.0 | Fecha: 22 de septiembre de 2025 | Autor: Marcos Losada García</p>
</header>

<main>
    <section>
        <h2>1. Introducción</h2>
        <h3>1.1. Propósito</h3>
        <p>Este documento describe la arquitectura de software de la aplicación "Swing Demo". Su objetivo es proporcionar una visión general de la estructura del sistema, los principios de diseño aplicados y los patrones arquitectónicos utilizados. Servirá como guía para el desarrollo, mantenimiento y evolución de la aplicación.</p>
        <h3>1.2. Alcance</h3>
        <p>La arquitectura descrita aplica a una aplicación de escritorio monolítica desarrollada en Java con la librería gráfica Swing. El diseño se centra en la escalabilidad, mantenibilidad y un alto grado de desacoplamiento entre sus componentes.</p>
    </section>

    <section>
        <h2>2. Visión Arquitectónica General</h2>
        <p>La aplicación se basa en una arquitectura <strong>Monolítica Modular</strong>, organizada mediante el principio <strong>Package-by-Layered-Feature</strong>.</p>
        <ul>
            <li><strong>Monolítica:</strong> Toda la aplicación se despliega como una única unidad ejecutable (un fichero JAR).</li>
            <li><strong>Modular:</strong> A pesar de ser un monolito, el código está organizado en módulos de negocio (o "features") que son cohesivos y están débilmente acoplados entre sí.</li>
            <li><strong>Package-by-Layered-Feature:</strong> Es la estrategia de organización del código. La estructura de paquetes de primer nivel corresponde a las funcionalidades de negocio (ej. user, order). Dentro de cada funcionalidad, el código se organiza por capas técnicas (mvc, service, data, etc.).</li>
        </ul>
        <p>Este enfoque combina la simplicidad de despliegue de un monolito con la escalabilidad y mantenibilidad de un diseño modular.</p>
    </section>

    <section>
        <h2>3. Estructura de Paquetes</h2>
        <p>La estructura de paquetes es el reflejo directo de la arquitectura.</p>
        <pre><code>com.losadagm.demo
├── config/                 // Configuración global (ej. logging, propiedades).
├── shared/                 // Clases de utilidad compartidas por toda la aplicación.
│   └── db/                 // Infraestructura de base de datos (DatabaseManager).
├── main/                   // Punto de entrada de la aplicación.
│   └── AppMain.java
└── user/                   // &lt;&lt; MÓDULO DE FUNCIONALIDAD "USER" &gt;&gt;
    ├── mvc/                // Capa de Presentación (Patrón MVC + Observer).
    │   ├── UserModel.java
    │   ├── UserView.java
    │   └── UserController.java
    ├── UserFacade.java     // Fachada pública del módulo.
    └── internal/           // Implementación interna, no visible para otros módulos.
        ├── domain/         // Entidades de dominio (POJOs).
        │   └── User.java
        ├── service/        // Lógica de negocio (Patrón Service Layer).
        │   └── UserServiceImpl.java
        └── data/           // Acceso a datos (Patrón DAO).
            ├── UserDao.java
            └── UserDaoDbImpl.java
</code></pre>
    </section>

    <section>
        <h2>4. Descripción de las Capas y Patrones</h2>
        <h3>4.1. Capa de Presentación (Presentation Layer)</h3>
        <p><strong>Responsabilidad:</strong> Mostrar la interfaz de usuario (UI) y capturar las interacciones del usuario.</p>
        <p><strong>Patrones Clave:</strong> MVC (Model-View-Controller) y Observer.</p>
        <ul>
            <li><strong>Model</strong> (ej. <code>UserModel.java</code>): Es un ViewModel que contiene el estado de la vista. No contiene lógica de negocio. Es un <code>Observable</code>.</li>
            <li><strong>View</strong> (ej. <code>UserView.java</code>): Un <code>JPanel</code> o <code>JFrame</code> que muestra los datos del Modelo. Es un <code>Observer</code> que se actualiza automáticamente cuando el Modelo cambia.</li>
            <li><strong>Controller</strong> (ej. <code>UserController.java</code>): Recibe eventos de la Vista y orquesta la respuesta, llamando a la Fachada de negocio y actualizando el Modelo.</li>
        </ul>

        <h3>4.2. Capa de Servicio (Service Layer)</h3>
        <p><strong>Responsabilidad:</strong> Contener la lógica de negocio central de la aplicación.</p>
        <p><strong>Patrones Clave:</strong> Fachada (Facade) y Service Layer.</p>
        <ul>
            <li><strong>Facade</strong> (ej. <code>UserFacade.java</code>): Es el punto de entrada público y simplificado a la funcionalidad del módulo.</li>
            <li><strong>Service Layer</strong> (ej. <code>UserServiceImpl.java</code>): Implementa las reglas de negocio específicas.</li>
        </ul>

        <h3>4.3. Capa de Datos (Data Layer)</h3>
        <p><strong>Responsabilidad:</strong> Abstraer el acceso a la fuente de datos (JDBC).</p>
        <p><strong>Patrones Clave:</strong> DAO (Data Access Object).</p>
        <ul>
            <li><strong>DAO Interface</strong> (ej. <code>UserDao.java</code>): Define el contrato para las operaciones de persistencia (CRUD).</li>
            <li><strong>DAO Implementation</strong> (ej. <code>UserDaoDbImpl.java</code>): Implementa el contrato usando SQL y el <code>DatabaseManager</code>.</li>
            <li><strong>Infraestructura:</strong> El <code>DatabaseManager</code> gestiona el pool de conexiones (C3P0) y las transacciones.</li>
        </ul>
    </section>

    <section>
        <h2>5. Flujo de Datos y Control</h2>
        <p>Un flujo de interacción típico (ej. refrescar una lista de usuarios) sigue estos pasos:</p>
        <ol>
            <li><strong>View:</strong> El usuario hace clic en el botón "Refrescar". La <code>UserView</code> notifica al <code>UserController</code>.</li>
            <li><strong>Controller:</strong> El <code>UserController</code> llama al método <code>getAllUsers()</code> de la <code>UserFacade</code>.</li>
            <li><strong>Facade:</strong> La <code>UserFacade</code> delega la llamada a su <code>UserService</code> interno.</li>
            <li><strong>Service:</strong> El <code>UserServiceImpl</code> llama al método <code>findAll()</code> de su <code>UserDao</code>.</li>
            <li><strong>DAO:</strong> El <code>UserDaoDbImpl</code> ejecuta la consulta SQL a través del <code>DatabaseManager</code>.</li>
            <li><strong>Retorno:</strong> Los datos viajan de vuelta por las mismas capas, el <code>UserController</code> actualiza el <code>UserModel</code>.</li>
            <li><strong>Observer:</strong> El <code>UserModel</code> notifica a su <code>Observer</code> (la <code>UserView</code>) que su estado ha cambiado.</li>
            <li><strong>View:</strong> La <code>UserView</code> se actualiza, redibujando la tabla con los nuevos datos.</li>
        </ol>
    </section>

    <section>
        <h2>6. Principios de Diseño Clave</h2>
        <ul>
            <li><strong>Separación de Responsabilidades (SoC):</strong> Cada capa y clase tiene una única responsabilidad bien definida.</li>
            <li><strong>Inversión de Dependencias (DIP):</strong> Las capas de alto nivel dependen de abstracciones (interfaces), no de implementaciones concretas.</li>
            <li><strong>Encapsulación y Ocultación de Información:</strong> Los paquetes <code>internal</code> ocultan detalles de implementación, forzando la comunicación a través de fachadas públicas.</li>
        </ul>
    </section>
</main>

<footer>
    <p>© 2025 Marcos Losada García</p>
</footer>

</body>
</html>
