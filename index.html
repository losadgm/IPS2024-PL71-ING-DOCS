<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Arquitectura del Proyecto: IPS Java/Swing</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<header>
    <h1>Arquitectura del proyecto: IPS Java/Swing</h1>
    <p>Versión: 1.1 | Fecha: 22 de septiembre de 2025 | Autor: Marcos Losada García</p>
    <p class="changelog"><strong>Cambios:</strong> Añadido Apéndice A con un caso de uso práctico.</p>
</header>

<main>
    <section>
        <h2>1. Introducción</h2>
        <h3>1.1. Propósito</h3>
        <p>Este documento describe la arquitectura de software de la aplicación "Swing Demo". Su objetivo es proporcionar una visión general de la estructura del sistema, los principios de diseño aplicados y los patrones arquitectónicos utilizados. Servirá como guía para el desarrollo, mantenimiento y evolución de la aplicación.</p>
        <h3>1.2. Alcance</h3>
        <p>La arquitectura descrita aplica a una aplicación de escritorio monolítica desarrollada en Java con la librería gráfica Swing. El diseño se centra en la escalabilidad, mantenibilidad y un alto grado de desacoplamiento entre sus componentes.</p>
    </section>

    <section>
        <h2>2. Visión Arquitectónica General</h2>
        <p>La aplicación se basa en una arquitectura <strong>Monolítica Modular</strong>, organizada mediante el principio <strong>Package-by-Layered-Feature</strong>.</p>
        <ul>
            <li><strong>Monolítica:</strong> Toda la aplicación se despliega como una única unidad ejecutable (un fichero JAR).</li>
            <li><strong>Modular:</strong> A pesar de ser un monolito, el código está organizado en módulos de negocio (o "features") que son cohesivos y están débilmente acoplados entre sí.</li>
            <li><strong>Package-by-Layered-Feature:</strong> Es la estrategia de organización del código. La estructura de paquetes de primer nivel corresponde a las funcionalidades de negocio (ej. user, order). Dentro de cada funcionalidad, el código se organiza por capas técnicas (mvc, service, data, etc.).</li>
        </ul>
        <p>Este enfoque combina la simplicidad de despliegue de un monolito con la escalabilidad y mantenibilidad de un diseño modular.</p>
    </section>

    <section>
        <h2>3. Estructura de Paquetes</h2>
        <p>La estructura de paquetes es el reflejo directo de la arquitectura.</p>
        <pre><code>com.losadagm.demo
├── config/                 // Configuración global (ej. logging, propiedades).
├── shared/                 // Clases de utilidad compartidas por toda la aplicación.
│   └── db/                 // Infraestructura de base de datos (DatabaseManager).
├── main/                   // Punto de entrada de la aplicación.
│   └── AppMain.java
└── user/                   // &lt;&lt; MÓDULO DE FUNCIONALIDAD "USER" &gt;&gt;
    ├── mvc/                // Capa de Presentación (Patrón MVC + Observer).
    │   ├── UserModel.java
    │   ├── UserView.java
    │   └── UserController.java
    ├── UserFacade.java     // Fachada pública del módulo.
    └── internal/           // Implementación interna, no visible para otros módulos.
        ├── domain/         // Entidades de dominio (POJOs).
        │   └── User.java
        ├── service/        // Lógica de negocio (Patrón Service Layer).
        │   └── UserServiceImpl.java
        └── data/           // Acceso a datos (Patrón DAO).
            ├── UserDao.java
            └── UserDaoDbImpl.java
</code></pre>
    </section>

    <section>
        <h2>4. Descripción de las Capas y Patrones</h2>
        <h3>4.1. Capa de Presentación (Presentation Layer)</h3>
        <p><strong>Responsabilidad:</strong> Mostrar la interfaz de usuario (UI) y capturar las interacciones del usuario.</p>
        <p><strong>Patrones Clave:</strong> MVC (Model-View-Controller) y Observer.</p>
        <ul>
            <li><strong>Model</strong> (ej. <code>UserModel.java</code>): Es un ViewModel que contiene el estado de la vista. No contiene lógica de negocio. Es un <code>Observable</code>.</li>
            <li><strong>View</strong> (ej. <code>UserView.java</code>): Un <code>JPanel</code> o <code>JFrame</code> que muestra los datos del Modelo. Es un <code>Observer</code> que se actualiza automáticamente cuando el Modelo cambia.</li>
            <li><strong>Controller</strong> (ej. <code>UserController.java</code>): Recibe eventos de la Vista y orquesta la respuesta, llamando a la Fachada de negocio y actualizando el Modelo.</li>
        </ul>

        <h3>4.2. Capa de Servicio (Service Layer)</h3>
        <p><strong>Responsabilidad:</strong> Contener la lógica de negocio central de la aplicación.</p>
        <p><strong>Patrones Clave:</strong> Fachada (Facade) y Service Layer.</p>
        <ul>
            <li><strong>Facade</strong> (ej. <code>UserFacade.java</code>): Es el punto de entrada público y simplificado a la funcionalidad del módulo.</li>
            <li><strong>Service Layer</strong> (ej. <code>UserServiceImpl.java</code>): Implementa las reglas de negocio específicas.</li>
        </ul>

        <h3>4.3. Capa de Datos (Data Layer)</h3>
        <p><strong>Responsabilidad:</strong> Abstraer el acceso a la fuente de datos (JDBC).</p>
        <p><strong>Patrones Clave:</strong> DAO (Data Access Object).</p>
        <ul>
            <li><strong>DAO Interface</strong> (ej. <code>UserDao.java</code>): Define el contrato para las operaciones de persistencia (CRUD).</li>
            <li><strong>DAO Implementation</strong> (ej. <code>UserDaoDbImpl.java</code>): Implementa el contrato usando SQL y el <code>DatabaseManager</code>.</li>
            <li><strong>Infraestructura:</strong> El <code>DatabaseManager</code> gestiona el pool de conexiones (C3P0) y las transacciones.</li>
        </ul>
    </section>

    <section>
        <h2>5. Flujo de Datos y Control</h2>
        <p>Un flujo de interacción típico (ej. refrescar una lista de usuarios) sigue estos pasos:</p>
        <ol>
            <li><strong>View:</strong> El usuario hace clic en el botón "Refrescar". La <code>UserView</code> notifica al <code>UserController</code>.</li>
            <li><strong>Controller:</strong> El <code>UserController</code> llama al método <code>getAllUsers()</code> de la <code>UserFacade</code>.</li>
            <li><strong>Facade:</strong> La <code>UserFacade</code> delega la llamada a su <code>UserService</code> interno.</li>
            <li><strong>Service:</strong> El <code>UserServiceImpl</code> llama al método <code>findAll()</code> de su <code>UserDao</code>.</li>
            <li><strong>DAO:</strong> El <code>UserDaoDbImpl</code> ejecuta la consulta SQL a través del <code>DatabaseManager</code>.</li>
            <li><strong>Retorno:</strong> Los datos viajan de vuelta por las mismas capas, el <code>UserController</code> actualiza el <code>UserModel</code>.</li>
            <li><strong>Observer:</strong> El <code>UserModel</code> notifica a su <code>Observer</code> (la <code>UserView</code>) que su estado ha cambiado.</li>
            <li><strong>View:</strong> La <code>UserView</code> se actualiza, redibujando la tabla con los nuevos datos.</li>
        </ol>
    </section>

    <section>
        <h2>6. Principios de Diseño Clave</h2>
        <ul>
            <li><strong>Separación de Responsabilidades (SoC):</strong> Cada capa y clase tiene una única responsabilidad bien definida.</li>
            <li><strong>Inversión de Dependencias (DIP):</strong> Las capas de alto nivel dependen de abstracciones (interfaces), no de implementaciones concretas.</li>
            <li><strong>Encapsulación y Ocultación de Información:</strong> Los paquetes <code>internal</code> ocultan detalles de implementación, forzando la comunicación a través de fachadas públicas.</li>
        </ul>
    </section>

    <!-- APÉNDICE AÑADIDO -->
    <section id="apendice">
        <h2>Apéndice A: Aplicación Práctica de la Arquitectura - Caso de Uso</h2>
        
        <h3>A.1. Escenario del Caso de Uso</h3>
        <p>Se considera un escenario donde la aplicación tiene una interfaz de usuario (UI) simple, consistente en un único panel de control (Dashboard), pero maneja una lógica de negocio compleja que involucra múltiples entidades de dominio (User, Product, Order).</p>
        <p><strong>Requisito del caso de uso:</strong> El usuario hace clic en un botón "Crear Nuevo Pedido" en el Dashboard. Esta acción requiere obtener información del usuario, verificar el stock del producto y finalmente, crear un nuevo pedido en la base de datos.</p>
        
        <h3>A.2. Estructura de Paquetes en este Escenario</h3>
        <p>En este caso, la arquitectura se manifiesta de la siguiente manera: solo la funcionalidad del Dashboard tiene una capa de presentación mvc. Las demás funcionalidades (user, product, order) exponen su lógica a través de fachadas, pero no tienen vistas propias.</p>
        <pre><code>com.losadagm.demo
│
├── dashboard/                 // Módulo con UI.
│   ├── mvc/
│   │   ├── DashboardModel.java
│   │   ├── DashboardView.java
│   │   └── DashboardController.java
│   └── DashboardFacade.java
│
├── user/                      // Módulo "sin cabeza" (headless).
│   ├── UserFacade.java
│   └── internal/
│
├── product/                   // Módulo "sin cabeza".
│   ├── ProductFacade.java
│   └── internal/
│
└── order/                     // Módulo "sin cabeza".
    ├── OrderFacade.java
    └── internal/
</code></pre>

        <h3>A.3. Flujo de Control Detallado</h3>
        <p>El flujo para "Crear Nuevo Pedido" demuestra cómo las distintas funcionalidades colaboran sin acoplarse directamente, orquestadas por el DashboardController y las fachadas.</p>
        
        <h4>Evento de UI (DashboardView):</h4>
        <p>El usuario introduce los datos del pedido (ID de usuario, SKU del producto, cantidad) y hace clic en "Crear Pedido". La <code>DashboardView</code> captura el evento y llama a su controlador: <code>controller.handleCreateOrderRequest(userId, productSku, quantity);</code>.</p>
        
        <h4>Orquestación en el Controlador (DashboardController):</h4>
        <p>El <code>DashboardController</code> recibe la petición. Su rol no es saber cómo se crea un pedido, sino delegar la tarea a los expertos. Invoca a la fachada de pedidos: <code>orderFacade.createNewOrder(userId, productSku, quantity);</code>.</p>
        
        <h4>Lógica de Negocio en la Fachada (OrderFacade):</h4>
        <p><code>OrderFacade.createNewOrder()</code> es el método que orquesta la operación completa. Para ello, colabora con otras fachadas, pero nunca con sus detalles internos.</p>
        <ul>
            <li><strong>Paso 1: Validar Usuario.</strong> Llama a la fachada de usuarios: <code>Optional&lt;UserDTO&gt; user = userFacade.findUserById(userId);</code>. Si el usuario no existe, la operación falla.</li>
            <li><strong>Paso 2: Verificar Stock.</strong> Llama a la fachada de productos: <code>boolean hasStock = productFacade</code><code>.checkStockAvailability(productSku, quantity);</code>. Si no hay stock, la operación falla.</li>
            <li><strong>Paso 3: Ejecutar Lógica Interna.</strong> Si las validaciones son correctas, la <code>OrderFacade</code> llama a su propio servicio interno (<code>orderService</code>) para que realice el trabajo de bajo nivel: crear la entidad <code>Order</code>, actualizar el stock y guardar todo en la base de datos dentro de una única transacción.</li>
        </ul>

        <h4>Actualización de la UI:</h4>
        <p>La <code>OrderFacade</code> devuelve un resultado. El <code>DashboardController</code> lo recibe y le pide a la <code>DashboardFacade</code> que refresque los datos del panel. Esta fachada obtiene los datos actualizados, los pone en el <code>DashboardModel</code>, y el modelo notifica a la <code>DashboardView</code> (su Observer) para que se redibuje y muestre el estado más reciente.</p>

        <h3>A.4. Conclusiones del Caso de Uso</h3>
        <p>Este ejemplo demuestra los beneficios clave de la arquitectura:</p>
        <ul>
            <li><strong>Desacoplamiento:</strong> El módulo <code>order</code> no sabe nada sobre la existencia de un Dashboard. Su única puerta de entrada es <code>OrderFacade</code>.</li>
            <li><strong>Cohesión:</strong> Toda la lógica para crear un pedido está contenida dentro del módulo <code>order</code>.</li>
            <li><strong>Simplicidad en la UI:</strong> El <code>DashboardController</code> es simple y legible, ya que solo contiene llamadas de alto nivel a las fachadas.</li>
            <li><strong>Escalabilidad:</strong> Añadir una nueva funcionalidad (ej. <code>Invoice</code>) simplemente requiere crear un nuevo módulo con su propia fachada.</li>
        </ul>
    </section>
</main>

<footer>
    <p>© 2025 Marcos Losada García</p>
</footer>

</body>
</html>
